\chapter{Sistemi di Autenticazione}

[INSERIRE SLIDES 1-48]

\section{Intermediari fidati}

\subsection{Distribuzione delle chiavi segrete}
Si assuma che la sicurezza di una rete si basi sulla tecnologia a chiave segreta. Se la rete ha \textit{n} nodi, e
ogni computer \textit{c} deve poter autenticare ogni altro nodo, allora \textit{c} deve memorizzare \textit{n – 1} chiavi (una per ogni altro sistema della rete): se un nuovo nodo viene aggiunto alla rete dovrebbero essere generate \textit{n} nuove chiavi per avere una chiave segreta condivisa con tutti gli \textit{n} nodi pre-esistenti. \\
Sarebbe pertanto necessario distribuire tali \textit{n} chiavi in modo sicuro a tutti gli altri nodi della rete, ma tale strategia di gestione delle chiavi può aver senso solo per reti molto piccole!
[ins figura 50]
Un centro di distribuzione delle chiavi, \textbf{K}ey \textbf{D}istribution \textbf{C}enter (KDC), agevola la gestione/distribuzione delle chiavi segrete: conosce le chiavi di tutti i nodi e se un nuovo nodo si aggiunge alla rete, sola una chiave segreta, condivisa tra quel nodo e il KDC, deve essere generata.
[ins figura 52]

\subsubsection{Centri di distribuzione delle chiavi}
Se un nodo $\alpha$ deve comunicare con un nodo $\beta$, $\alpha$ comunica con il KDC in modo sicuro, e usando la loro chiave segreta condivisa $K_{\alpha KDC}$ gli chiede di inviargli una chiave per comunicare con $\beta$; il KDC autentica $\alpha$, sceglie un numero random $R_{\alpha\beta}$ da usare come chiave segreta condivisa tra $\alpha$ e $\beta$; cifra $R_{\alpha\beta}$ con la chiave segreta $K_{\beta KDC}$ che condivide con $\beta$, e trasmette a $\beta$ $R_{\alpha\beta} $ cifrata insieme alle istruzioni che $\beta$ deve usare per comunicare con $\alpha$ (in genere, il KDC non trasmette direttamente $ R_{\alpha\beta} $ cifrato a $\beta$, per confinare il suo intervento all'interazione con un solo nodo e prevenire attacchi di DoS, ma lo invia ad $\alpha$ che poi lo inoltrerà a $\beta$:
il messaggio cifrato per $\beta$ che il KDC invia ad $\alpha$, e che $\alpha$ dovrà inoltrare a $\beta$ e detto \textbf{ticket}, che, oltre a contenere $ R_{\alpha\beta} $ contiene altre informazioni utili, come data di scadenza, nome del nodo $\alpha$, ecc.). \\ \\
I KDC semplificano la distribuzione delle chiavi: quando un nuovo utente deve essere aggiunto alla rete, o quando si sospetta che una chiave d’utente sia stata compromessa, c’è un singolo punto della rete, il KDC, la cui configurazione deve essere aggiornata. L’alternativa al KDC è installare le informazioni di un utente in ciascun server ove potrebbe accedere. \\
L'uso dei KDC comporta però i seguenti svantaggi: 
\begin{itemize}
\item contiene tutte le informazioni per impersonare un utente ad un qualsiasi altro utente, perciò, se compromesso, tutte le risorse di rete risultano vulnerabili
\item è un "single point of failure", quindi in caso di guasto nessuno può iniziare una comunicazione con nuovi utenti (le chiavi precedentemente distribuite continuano a funzionare)
\item è possibile avere più KDC (KDC multipli) con lo stesso database di chiavi, ma ciò comporta una maggior complessità di gestione, costi extra per le macchine e per la replicazione dei protocolli e maggiori vulnerabilità (è necessario proteggere più target da eventuali attacchi)
\item può costituire un collo di bottiglia (in questa caso, avere più di un KDC può alleviare tale problema)
\end{itemize}  

\subsubsection{Autorità di certificazione}
La distribuzione delle chiavi è più facile con la crittografia a chiave pubblica: ogni nodo deve custodire soltanto la propria chiave privata e tutte le chiavi pubbliche possono essere accessibili in un unico punto. \\
Anche in questo caso continuano ad esserci dei problemi: chi garantisce che le chiavi pubbliche disponibili in un dato punto siano corrette (corrispondano realmente alle entità a cui sono associate)? \\
Per evitare la falsificazione delle chiavi pubbliche si ricorre alle Autorità di Certificazione. \\
Una Autorità di Certificazione, \textbf{C}ertification \textbf{A}uthority CA, è un intermediario fidato che genera i certificati, cioè dei messaggi firmati dalla CA contenenti il nome, la chiave pubblica ed altre informazioni di uno specifico nodo. Tutti i nodi dovranno essere pre-configurati con la chiave pubblica della CA, in modo tale da poter verificare la sua firma sui certificati rilasciati: si tratta dell’unica (in questo specifico esempio) chiave pubblica che devono conoscere a priori. \\ \\
Lo \textbf{standard X.509} per le infrastrutture a chiave pubblica ha definito il formato standard di un certificato. \\
Un \textbf{certificato} contiene:
\begin{itemize}
\item il nome utente (persone fisica, organizzazione, server, applicazione, …)
\item la chiave pubblica dell’utente
\item la data di scadenza
\item un numero seriale
\item la firma, della CA che lo ha emesso, dell’intero contenuto del certificato
\end{itemize}
[ins figura 61]
I certificati possono essere memorizzati nel luogo ritenuto più conveniente (e.g. in un directory service), oppure
ciascun nodo può memorizzare i certificati d’interesse e trasmetterli durante lo "scambio di autenticazione". 
In un certo senso le CA sono la controparte dei KDC nelle infrastrutture a chiave pubblica: CA e KDC costituiscono l'intermediario fidato la cui compromissione può arrecare seri danni all'integrità della rete. \\ \\
Si noti che non è necessario che la CA sia on-line: può risiedere in una stanza fisicamente ben protetta (magari con una guardia) e si può limitare l'accesso alla CA ad una sola persona di grande fiducia. Questa persona, interagendo con la CA, genera il certificato di un dato utente, lo memorizza su un qualche supporto di memoria esterna che può consegnare "a mano" al diretto interessato. Se la CA non è on-line, nessun potenziale intruso può accedervi per ottenere informazioni utili, non deve implementare protocolli di rete che richiedono elevata efficienza computazionale, quindi può essere implementata da un dispositivo estremamente semplice e pertanto molto più sicuro.\\ 
Se la CA dovesse "crashare", la rete continuerebbe a funzionare, ma non sarebbe possibile aggiungere nuovi utenti o
revocare certificati compromessi o di utenti sospetti, pertanto non è essenziale avere CA multiple. \\
I certificati sono poco sensibili ad eventuali attacchi: se memorizzati in modo conveniente, ma potenzialmente
insicuro (ad es. in un servizio di directory), un sabotatore può cancellare i certificati, impedendo l’accesso ai corrispondenti nodi della rete (attacco DOS) ma non può creare dei certificati fasulli o modificarli in qualche modo se non dispone della chiave privata della CA.\\
Una CA compromessa non puo decifrare le conversazioni tra due nodi (reali) da lei serviti (mentre un KDC compromesso può decifrare tutte le conversazioni tra coppie di nodi da lui serviti), pertanto una CA compromessa può ingannare un utente, diciamo Alice, inviandogli una falsa chiave pubblica di Bob e riuscire ad impersonare Bob in una comunicazione con Alice, ma non può decifrare una comunicazione tra la vera Alice e il vero Bob: quindi la compromissione di una CA rimane un fatto molto grave, ma non quanto la compromissione di un KDC. \\ \\
Le CA presentano comunque il seguente svantaggio rispetto i KDC: \\
Supponiamo che Fred offra dei servizi di hosting per conto dell'azienda X SpA; la società X SpA fornisce a Fred un certificato (rilasciato a favore della X SpA) necessario ad autenticare il server, pertanto Fred conosce la chiave privata della chiave pubblica certificata. Supponiamo inoltre che a causa di un contrasto con Fred, la X SpA decida di interrompere il rapporto di lavoro; se il certificato è ancora valido Fred può continuare a rendere dei servizi per conto della X SpA, magari anche danneggiandola. Per la X SpA sarebbe importante informare gli utenti di non accettare il certificato generato per Fred e ancora in corso di validità. \\
Con i KDC tale problema è di facile soluzione: basta rimuovere $K_{Fred}$ dal KDC.\\ 
Ovviamente si ha un problema analogo anche quando viene smarrita, o peggio rubata, la chiave privata associata alla chiave pubblica certificata.\\
Nel caso delle CA non è facile estromettere qualcuno che detiene una chiave privata la cui chiave pubblica è certificata (si noti che potrebbe essere molto rischioso attendere la scadenza naturale del certificato); in queste situazioni conviene revocare il certificato: si revoca un certificato quando, a partire da un certo momento, non devono essere più considerate valide le firme generate con la chiave privata abbinata alla chiave pubblica contenuta nel certificato. \\ \\
La \textbf{revoca} di un certificato si attua inserendo un riferimento al certificato all'interno di una lista di revoca (\textbf{C}ertificate \textbf{R}evocation \textbf{L}ist CRL), che elenca i numeri seriali di certificati da non onorare. Ogni CA pubblica periodicamente una nuova CRL che contiene tutti i certificati revocati e non scaduti.\\
Un certificato è valido se:
\begin{itemize}
\item la firma della CA è valida,
\item non è scaduto
\item non è inserito nella CRL più recente della CA che lo ha emesso
\item la CRL ha una data e ora di emissione
\end{itemize}
Se un'applicazione vuole assicurarsi che nessuno dei certificati che onora sia stato revocato entro un'ora prima
della verifica, allora deve essere trascorsa al più un ora dal momento in cui la CRL, consultata da tale applicazione, è stata emessa; quindi, in questo caso, una nuova CRL deve essere pubblicata con una cadenza di un'ora.\\
Un intruso potrebbe cancellare l'ultima CRL, in tal caso le applicazioni configurate per consultare esclusivamente CRL pubblicate nell'ultima ora si rifiuteranno di onorare tutti i certificati, ma l'intruso non può impersonare un utente valido distruggendo la CRL o sovrascrivendola con una CRL più vecchia.\\
Lo standard X.509 ha definito anche il formato delle CRL, in base al quale una CRL deve includere:
\begin{itemize}
\item una lista di numeri seriali di certificati revocati e non scaduti
\item e una data e ora di emissione della CRL
\item la firma dell'intera lista con la chiave privata della CA
\end{itemize}
\paragraph{Problema}
Supponendo che Bob sia un'applicazione che deve autenticare l'utente Alice, illustrare un possibile protocollo di
autenticazione a chiave pubblica, che includa una verifica dell'appartenenza della chiave pubblica all'utente Alice.
\\ \\
Chiaramente Bob ha bisogno del certificato di Alice, \textit{$Cert_{Alice}$}, e di una CRL recente: Bob può ottenerli da un servizio di directory, oppure Alice li trasmette a Bob. 
In riferimento alla FIGURA, una possibile soluzione è:
\begin{itemize}
\item Bob recupera il certificato di Alice \textit{$Cert_{Alice}$} e una CRL recente
\item Consultando il certificato \textit{$Cert_{Alice}$} individua la chiave pubblica di Alice \textit{$PU_{Alice}$}
\item Verifica la correttezza di \textit{$PU_{Alice}$} come segue:
\begin{itemize}
\item se il certificato \textit{$Cert_{Alice}$} è correttamente firmato dalla CA che lo ha emesso e non è scaduto, e
la CRL è correttamente firmata dalla CA ed è sufficientemente recente e non contiene il certificato \textit{$Cert_{Alice}$}, allora Bob conclude che \textit{$PU_{Alice}$} è corretta (quindi è quella nel certificato)
\end{itemize}
\item Bob ed Alice iniziano uno scambio di messaggi seguendo uno schema di autenticazione a chiave pubblica, ad esempio:
\begin{itemize}
\item Bob invia una sfida \textit{R} ad Alice
\item Alice firma \textit{R} con la propria chiave privata ed invia [\textit{R}]\textit{$NONLOSO_{Alice}$} a Bob
\item Bob verifica la firma di Alice ed in caso affermativo autentica Alice
\end{itemize}
\end{itemize}
[ins fig 76]

